from __future__ import annotations

import json
from pathlib import Path
from typing import Any, Dict, Iterable, List

# ---------------------------------------------------------
# PUBLIC EXPORTS
# ---------------------------------------------------------
__all__ = [
    "HumanStack",
    "load_human_stack",
    "save_human_stack",
    "update_my_profile",
    "search_by_skills",
    "search_by_project",
    "delete_profile_by_id",
]

# Import SAMPLE_HUMANS from your app.py (first-run seeding)
from services.ui.app import SAMPLE_HUMANS


# ---------------------------------------------------------
# INTERNAL UTILITIES
# ---------------------------------------------------------
def _ensure_list(value: Any) -> List:
    if isinstance(value, list):
        return value
    if value is None:
        return []
    if isinstance(value, str):
        return [value]
    return list(value)


# ---------------------------------------------------------
# MAIN CLASS
# ---------------------------------------------------------
class HumanStack:
    def __init__(self, path: str | Path | None = None):
        # Default file location: services/ui/data/human_stack.json
        self.path = Path(path) if path else Path(__file__).resolve().parents[1] / "data" / "human_stack.json"
        self.path.parent.mkdir(parents=True, exist_ok=True)

    # -----------------------------
    # Load JSON storage
    # -----------------------------
    def load(self) -> List[Dict]:
        if not self.path.exists():
            return []

        try:
            with open(self.path, "r", encoding="utf-8") as handle:
                data = json.load(handle)
            return data if isinstance(data, list) else []
        except json.JSONDecodeError:
            return []

    # -----------------------------
    # Save JSON storage
    # -----------------------------
    def save(self, records: List[Dict]) -> None:
        temp_path = self.path.with_suffix(".tmp")
        with open(temp_path, "w", encoding="utf-8") as handle:
            json.dump(records, handle, indent=2, ensure_ascii=False)
        temp_path.replace(self.path)

    # -----------------------------
    # Update or add profile
    # -----------------------------
    def add_or_update(self, profile: Dict) -> None:
        records = self.load()
        key_id = profile.get("id")
        key_name = profile.get("name")

        target_index = None
        for idx, entry in enumerate(records):
            if key_id and entry.get("id") == key_id:
                target_index = idx
                break
            if key_name and entry.get("name") == key_name:
                target_index = idx

        # Default fields if missing
        profile.setdefault("skills", [])
        profile.setdefault("superpowers", [])
        profile.setdefault("projects_built", [])
        profile.setdefault("public_profile", True)

        if target_index is not None:
            # UPDATE EXISTING
            records[target_index] = {**records[target_index], **profile}
        else:
            # ADD NEW
            records.append(profile)

        self.save(records)

    # -----------------------------
    # DELETE PROFILE BY ID
    # -----------------------------
    def delete(self, profile_id: str) -> None:
        records = self.load()
        new_records = [r for r in records if r.get("id") != profile_id]
        self.save(new_records)

    # -----------------------------
    # Search (skills)
    # -----------------------------
    def search_people(self, skills_query: str | Iterable[str] | None) -> List[Dict]:
        tokens = []
        if isinstance(skills_query, str):
            tokens = [token.lower() for token in skills_query.split() if token.strip()]
        elif isinstance(skills_query, Iterable):
            tokens = [str(token).lower() for token in skills_query if str(token).strip()]

        if not tokens:
            return []

        results = []
        for profile in self.load():
            combined = " ".join(
                _ensure_list(profile.get("skills")) +
                _ensure_list(profile.get("superpowers"))
            ).lower()

            if all(token in combined for token in tokens):
                results.append(profile)

        return results

    # -----------------------------
    # Search (projects)
    # -----------------------------
    def search_projects(self, text_query: str | Iterable[str] | None) -> List[Dict]:
        tokens = []
        if isinstance(text_query, str):
            tokens = [token.lower() for token in text_query.split() if token.strip()]
        elif isinstance(text_query, Iterable):
            tokens = [str(token).lower() for token in text_query if str(token).strip()]

        if not tokens:
            return []

        matches = []
        for profile in self.load():
            for project in _ensure_list(profile.get("projects_built")):
                combined = " ".join(
                    [
                        str(project.get("title", "")),
                        str(project.get("description", "")),
                        " ".join(_ensure_list(project.get("skills_used"))),
                    ]
                ).lower()

                if all(token in combined for token in tokens):
                    enriched = dict(project)
                    enriched["owner_name"] = profile.get("name")
                    matches.append(enriched)

        return matches


# ---------------------------------------------------------
# GLOBAL SINGLETON
# ---------------------------------------------------------
_GLOBAL_STACK = HumanStack()


# ---------------------------------------------------------
# PUBLIC API WRAPPERS
# ---------------------------------------------------------
def load_human_stack() -> List[Dict]:
    """
    Load JSON file.  
    If it's empty (first run), seed it with SAMPLE_HUMANS.
    """
    records = _GLOBAL_STACK.load()
    if not records:
        _GLOBAL_STACK.save(SAMPLE_HUMANS)
        return SAMPLE_HUMANS
    return records


def save_human_stack(records: List[Dict]) -> None:
    _GLOBAL_STACK.save(records)


def update_my_profile(profile: Dict) -> None:
    _GLOBAL_STACK.add_or_update(profile)


def delete_profile_by_id(profile_id: str) -> None:
    _GLOBAL_STACK.delete(profile_id)


def search_by_skills(query: str | Iterable[str] | None) -> List[Dict]:
    return _GLOBAL_STACK.search_people(query)


def search_by_project(text: str | Iterable[str] | None) -> List[Dict]:
    return _GLOBAL_STACK.search_projects(text)
